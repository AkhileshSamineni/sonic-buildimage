From 43dc405ac87123a27d1fc8c063a43a848b4eb897 Mon Sep 17 00:00:00 2001
From: Akhilesh Samineni <akhilesh.samineni@broadcom.com>
Date: Tue, 15 Dec 2020 17:49:20 -0800
Subject: [PATCH] Source-interface-and-Link-select-support for DHCPv4 Relay

---
 common/discover.c |   2 +
 common/socket.c   |  94 ++++++++++++++++++++++--------
 includes/dhcp.h   |   9 +--
 relay/dhcrelay.c  | 142 ++++++++++++++++++++++++++++++++++++----------
 4 files changed, 191 insertions(+), 56 deletions(-)

diff --git a/common/discover.c b/common/discover.c
index 06e0b12..dcf54f0 100644
--- a/common/discover.c
+++ b/common/discover.c
@@ -55,6 +55,8 @@ struct in_addr limited_broadcast;
 
 int local_family = AF_INET;
 struct in_addr local_address;
+struct interface_info *uplink = NULL;
+struct interface_info *src_intf = NULL;
 
 #ifdef DHCPv6
 /*
diff --git a/common/socket.c b/common/socket.c
index 483eb9c..1abef86 100644
--- a/common/socket.c
+++ b/common/socket.c
@@ -701,6 +701,27 @@ if_deregister6(struct interface_info *info) {
 }
 #endif /* DHCPv6 */
 
+#if defined(DHCPv6) || \
+        (defined(IP_PKTINFO) && defined(IP_RECVPKTINFO) && \
+         defined(USE_V4_PKTINFO))
+/*
+ * For both send_packet6() and receive_packet6() we need to allocate
+ * space for the cmsg header information.  We do this once and reuse
+ * the buffer.  We also need the control buf for send_packet() and
+ * receive_packet() when we use a single socket and IP_PKTINFO to
+ * send the packet out the correct interface.
+ */
+static void   *control_buf = NULL;
+static size_t  control_buf_len = 0;
+
+static void
+allocate_cmsg_cbuf(void) {
+        control_buf_len = CMSG_SPACE(sizeof(struct in6_pktinfo));
+        control_buf = dmalloc(control_buf_len, MDL);
+        return;
+}
+#endif /* DHCPv6, IP_PKTINFO ... */
+
 #if defined (USE_SOCKET_SEND) || defined (USE_SOCKET_FALLBACK)
 ssize_t send_packet (interface, packet, raw, len, from, to, hto)
 	struct interface_info *interface;
@@ -728,8 +749,56 @@ ssize_t send_packet (interface, packet, raw, len, from, to, hto)
 				log_fatal("setsockopt: IP_PKTINFO: %m");
 		}
 #endif
-		result = sendto (interface -> wfdesc, (char *)raw, len, 0,
-				 (struct sockaddr *)to, sizeof *to);
+		if (interface->ifp == NULL) {
+			struct msghdr m;
+			struct iovec v;
+			struct sockaddr_in dst;
+			struct in_pktinfo *pktinfo;
+			struct cmsghdr *cmsg;
+
+			/*
+			 * If necessary allocate space for the control message header.
+			 * The space is common between send and receive.
+			 */
+
+			if (control_buf == NULL) {
+				allocate_cmsg_cbuf();
+				if (control_buf == NULL) {
+					log_error("send_packet: unable to allocate cmsg header");
+					return(ENOMEM);
+				}
+			}
+			memset(control_buf, 0, control_buf_len);
+
+			/*
+			 * Initialize our message header structure.
+			 */
+			memset(&m, 0, sizeof(m));
+			memcpy(&dst, to, sizeof(dst));
+			m.msg_name = &dst;
+			m.msg_namelen = sizeof(dst);
+
+			v.iov_base = (char *)raw;
+			v.iov_len = len;
+			m.msg_iov = &v;
+			m.msg_iovlen = 1;
+
+			m.msg_control = control_buf;
+			m.msg_controllen = control_buf_len;
+			cmsg = CMSG_FIRSTHDR(&m);
+			INSIST(cmsg != NULL);
+			cmsg->cmsg_level = IPPROTO_IP;
+			cmsg->cmsg_type = IP_PKTINFO;
+			cmsg->cmsg_len = CMSG_LEN(sizeof(*pktinfo));
+			pktinfo = (struct in_pktinfo *)CMSG_DATA(cmsg);
+			memset(pktinfo, 0, sizeof(*pktinfo));
+			pktinfo->ipi_spec_dst = from;
+
+			result = sendmsg(interface->wfdesc, &m, 0);
+		} else {
+			result = sendto (interface -> wfdesc, (char *)raw, len, 0,
+					 (struct sockaddr *)to, sizeof *to);
+		}
 #ifdef IGNORE_HOSTUNREACH
 	} while (to -> sin_addr.s_addr == htonl (INADDR_BROADCAST) &&
 		 result < 0 &&
@@ -798,27 +867,6 @@ static size_t CMSG_SPACE(size_t len) {
 
 #endif /* DHCPv6 */
 
-#if defined(DHCPv6) || \
-	(defined(IP_PKTINFO) && defined(IP_RECVPKTINFO) && \
-	 defined(USE_V4_PKTINFO))
-/*
- * For both send_packet6() and receive_packet6() we need to allocate
- * space for the cmsg header information.  We do this once and reuse
- * the buffer.  We also need the control buf for send_packet() and
- * receive_packet() when we use a single socket and IP_PKTINFO to
- * send the packet out the correct interface.
- */
-static void   *control_buf = NULL;
-static size_t  control_buf_len = 0;
-
-static void
-allocate_cmsg_cbuf(void) {
-	control_buf_len = CMSG_SPACE(sizeof(struct in6_pktinfo));
-	control_buf = dmalloc(control_buf_len, MDL);
-	return;
-}
-#endif /* DHCPv6, IP_PKTINFO ... */
-
 #ifdef DHCPv6
 /* 
  * For both send_packet6() and receive_packet6() we need to use the 
diff --git a/includes/dhcp.h b/includes/dhcp.h
index 0a74137..324c8ff 100644
--- a/includes/dhcp.h
+++ b/includes/dhcp.h
@@ -179,10 +179,11 @@ struct dhcp_packet {
 
 
 /* Relay Agent Information option subtypes: */
-#define RAI_CIRCUIT_ID	1
-#define RAI_REMOTE_ID	2
-#define RAI_AGENT_ID	3
-#define RAI_LINK_SELECT	5
+#define RAI_CIRCUIT_ID       1
+#define RAI_REMOTE_ID        2
+#define RAI_AGENT_ID         3
+#define RAI_LINK_SELECT      5
+#define RAI_SERVER_OVERRIDE  11
 /* not yet assigned but next free value */
 #define RAI_RELAY_PORT  19
 
diff --git a/relay/dhcrelay.c b/relay/dhcrelay.c
index 1cd99b9..91acaec 100644
--- a/relay/dhcrelay.c
+++ b/relay/dhcrelay.c
@@ -116,7 +116,8 @@ struct server_list {
 	struct sockaddr_in to;
 } *servers;
 
-struct interface_info *uplink = NULL;
+extern struct interface_info *uplink;
+extern struct interface_info *src_intf;
 
 #ifdef DHCPv6
 struct stream_list {
@@ -244,6 +245,7 @@ char *progname;
 "                [-iu interface0 [ ... -iu interfaceN]\n" \
 "                [-id interface0 [ ... -id interfaceN]\n" \
 "                [-U interface]\n" \
+"                [-S source-interface]\n" \
 "                [-dt]\n"\
 "                server0 [ ... serverN]\n\n" DHCRELAY_OPTION82_USAGE \
 "       %s {--version|--help|-h}"
@@ -256,6 +258,7 @@ char *progname;
 "                [-iu interface0 [ ... -iu interfaceN]\n" \
 "                [-id interface0 [ ... -id interfaceN]\n" \
 "                [-U interface]\n" \
+"                [-S source-interface]\n" \
 "                [-dt]\n"\
 "                server0 [ ... serverN]\n\n" DHCRELAY_OPTION82_USAGE \
 "       %s {--version|--help|-h}"
@@ -311,6 +314,77 @@ usage(const char *sfmt, const char *sarg) {
 		  isc_file_basename(progname));
 }
 
+void parse_uplink_intf(char *intf_name)
+{
+	struct interface_info *tmp = NULL; isc_result_t status;
+
+	/* Check if -U interface is already present in the -iu list */
+	for (tmp = interfaces; tmp; tmp = tmp -> next) {
+		if (!strncmp(tmp->name, intf_name, sizeof(tmp->name)-1)) {
+			uplink = tmp;
+			log_error("%s: matching interface already exists for -U", intf_name);
+			break;
+		}
+	}
+	if (! uplink) {
+		/* Allocate the uplink interface */
+		status = interface_allocate(&uplink, MDL);
+		if (status != ISC_R_SUCCESS) {
+			log_fatal("%s: uplink interface_allocate: %s",
+				  intf_name, isc_result_totext(status));
+		}
+
+		if (strlen(intf_name) >= sizeof(uplink->name)) {
+			log_fatal("%s: uplink name too long,"
+				  " it cannot exceed: %ld characters",
+				  intf_name, (long)(sizeof(uplink->name) - 1));
+		}
+
+		uplink->name[sizeof(uplink->name) - 1] = 0x00;
+		strncpy(uplink->name, intf_name, sizeof(uplink->name) - 1);
+		interface_snorf(uplink, (INTERFACE_REQUESTED |
+					INTERFACE_STREAMS));
+		log_info("Uplink interface set to %s", intf_name);
+	}
+	/* Turn on -a, in case they don't do so explicitly */
+	add_agent_options = 1;
+	add_rfc3527_suboption = 1;
+}
+
+void parse_src_intf(char *intf_name)
+{
+	struct interface_info *tmp = NULL; isc_result_t status;
+
+	/* Check if -S interface is already present in the interfaces list */
+	for (tmp = interfaces; tmp; tmp = tmp -> next) {
+		if (!strncmp(tmp->name, intf_name, sizeof(tmp->name)-1)) {
+			src_intf = tmp;
+			log_error("%s: matching interface already exists for -S", intf_name);
+			break;
+		}
+	}
+	if (! src_intf) {
+		/* Allocate the source interface */
+		status = interface_allocate(&src_intf, MDL);
+		if (status != ISC_R_SUCCESS) {
+			log_fatal("%s: source interface_allocate: %s",
+				  intf_name, isc_result_totext(status));
+		}
+
+		if (strlen(intf_name) >= sizeof(src_intf->name)) {
+			log_fatal("%s: source name too long,"
+				  " it cannot exceed: %ld characters",
+				  intf_name, (long)(sizeof(src_intf->name) - 1));
+		}
+
+		src_intf->name[sizeof(src_intf->name) - 1] = 0x00;
+		strncpy(src_intf->name, intf_name, sizeof(src_intf->name) - 1);
+		interface_snorf(src_intf, (INTERFACE_REQUESTED |
+					  INTERFACE_STREAMS));
+		log_info("Source interface set to %s", intf_name);
+	}
+}
+
 int 
 main(int argc, char **argv) {
 	isc_result_t status;
@@ -569,28 +643,17 @@ main(int argc, char **argv) {
 				      ,argv[i]);
 			}
 
-			/* Allocate the uplink interface */
-			status = interface_allocate(&uplink, MDL);
-			if (status != ISC_R_SUCCESS) {
-				log_fatal("%s: uplink interface_allocate: %s",
-					 argv[i], isc_result_totext(status));
-			}
-		
-			if (strlen(argv[i]) >= sizeof(uplink->name)) {
-				log_fatal("%s: uplink name too long,"
-					  " it cannot exceed: %ld characters",
-					  argv[i], (long)(sizeof(uplink->name) - 1));
-			}
+			parse_uplink_intf(argv[i]);
+		} else if (!strcmp(argv [i], "-S")) {
+			if (++i == argc)
+				usage(use_noarg, argv[i-1]);
 
-			uplink->name[sizeof(uplink->name) - 1] = 0x00;
-			strncpy(uplink->name, argv[i],
-				sizeof(uplink->name) - 1);
-			interface_snorf(uplink, (INTERFACE_REQUESTED |
-						INTERFACE_STREAMS));
+			if (src_intf) {
+				usage("more than one source interface (-S) specified: %s"
+				      ,argv[i]);
+ 			}
 
-			/* Turn on -a, in case they don't do so explicitly */
-			add_agent_options = 1;
-			add_rfc3527_suboption = 1;
+			parse_src_intf(argv[i]);
 		} else if (!strcmp(argv[i], "-D")) {
 #ifdef DHCPv6
 			if (local_family_set && (local_family == AF_INET6)) {
@@ -1013,10 +1076,10 @@ do_relay4(struct interface_info *ip, struct dhcp_packet *packet,
 				&to, htop) < 0) {
 			++server_packet_errors;
 		} else {
-			log_debug("Forwarded BOOTREPLY for %s to %s",
+			log_debug("Forwarded BOOTREPLY for %s to %s on interface %s",
 			       print_hw_addr(packet->htype, packet->hlen,
 					      packet->chaddr),
-			       inet_ntoa(to.sin_addr));
+			       inet_ntoa(to.sin_addr), out->name);
 
 			++server_packets_relayed;
 		}
@@ -1114,8 +1177,21 @@ do_relay4(struct interface_info *ip, struct dhcp_packet *packet,
 		/* Otherwise, if we have a fallback interface, we send the packet
 		   on it. If not, we send the packet out all interfaces.*/
 		if (fallback_interface) {
+			struct in_addr from_addr;
+
+			if ((uplink != NULL) && (uplink->address_count)) {
+				from_addr = uplink->addresses[0];
+				log_debug("Uplink exists, setting from_addr to %s", inet_ntoa(from_addr));
+			} else if ((src_intf != NULL) && (src_intf->address_count)) {
+				from_addr = src_intf->addresses[0];
+				log_debug("Src_intf exists, setting from_addr to %s", inet_ntoa(from_addr));
+			} else {
+				from_addr = ip->addresses[0];
+				log_debug("No uplink or srcintf exists, setting from_addr to %s", inet_ntoa(from_addr));
+			}
+
 			if (send_packet(fallback_interface, NULL, packet,
-					length, ip->addresses[0],&sp->to, NULL) < 0) {
+					length, from_addr, &sp->to, NULL) < 0) {
 				++client_packet_errors;
 			} else {
 				log_debug("Forwarded BOOTREQUEST for %s to %s on fallback interface",
@@ -1521,7 +1597,7 @@ add_relay_agent_options(struct interface_info *ip, struct dhcp_packet *packet,
 	max = ((u_int8_t *)packet) + dhcp_max_agent_option_packet_length;
 
 	/* Add link selection suboption if enabled and we're the first relay */
-	adding_link_select = (add_rfc3527_suboption
+	adding_link_select = (add_rfc3527_suboption && (uplink != NULL) && (uplink->address_count)
 			      && (packet->giaddr.s_addr == 0));
 
 	/* Commence processing after the cookie. */
@@ -1657,8 +1733,8 @@ add_relay_agent_options(struct interface_info *ip, struct dhcp_packet *packet,
 
 		optlen = circuit_id_len + 2;  // RAI_CIRCUIT_ID + len
 
-		//log_debug("Sending on %s option82:circuit_id='%s' (%d)",
-		//		  ip->name, circuit_id_buf, (int)circuit_id_len);
+		log_debug("Sending on %s option82:circuit_id='%s' (%d)",
+				  ip->name, circuit_id_buf, (int)circuit_id_len);
 	}
 
 	/* option82: custom string for remote_id */
@@ -1672,12 +1748,13 @@ add_relay_agent_options(struct interface_info *ip, struct dhcp_packet *packet,
 
 		optlen += remote_id_len + 2;  // RAI_REMOTE_ID + len
 
-		//log_debug("Sending on %s option82:remote_id='%s' (%d)",
-		//		  ip->name, remote_id_buf, (int)remote_id_len);
+		log_debug("Sending on %s option82:remote_id='%s' (%d)",
+				  ip->name, remote_id_buf, (int)remote_id_len);
 	}
 
 	if (adding_link_select) {
 		optlen += 6;
+		optlen += 6; /* for server override */
 	}
 
 #ifdef RELAY_PORT
@@ -1730,6 +1807,13 @@ add_relay_agent_options(struct interface_info *ip, struct dhcp_packet *packet,
 			packet->giaddr = uplink->addresses[0];
 			log_debug ("Adding link selection suboption"
 				   " with addr: %s", inet_ntoa(giaddr));
+
+			*sp++ = RAI_SERVER_OVERRIDE;
+			*sp++ = 4u;
+			memcpy(sp, &giaddr.s_addr, 4);
+			sp += 4;
+			log_debug ("Adding server override suboption"
+				   " with addr: %s", inet_ntoa(giaddr));
 		}
 
 #ifdef RELAY_PORT
-- 
2.18.0

